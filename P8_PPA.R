# Description ----
# Learn Point Pattern Analysis (PPA)
# https://mgimond.github.io/Spatial/point-pattern-analysis-in-r.html 
# There are lots of sections that still not learn because i'm not understand ppp now.


# Data preparation ----
# The data objects consist of three spatial data layers:
#   1. starbucks: A ppp point layer of Starbucks stores in Massachusetts;
#   2. ma: An owin polygon layer of Massachusetts boundaries;
#   3. pop: An im raster layer of population density distribution.
load(url("https://github.com/mgimond/Spatial/raw/main/Data/ppa.RData")) 

# ppp object may or may not have attribute information
# only concern ourselves with the pattern generated by the points and not their attributes 
#   remove all marks
library(spatstat)
marks(starbucks)  <- NULL

# ppp like average neighbor analysis involve with boundary -> add ma boundary to starbucks
Window(starbucks) <- ma
plot(starbucks, main=NULL, cols=rgb(0,0,0,.2), pch=20)
hist(pop, main=NULL, las=1)

pop.lg <- log(pop)
hist(pop.lg, main=NULL, las=1)


# Density based analysis ----
## Quadrat density ----
Q <- quadratcount(starbucks, nx= 6, ny=3)          # Divide map
plot(starbucks, pch=20, cols="grey70", main=NULL)  # Plot points
plot(Q, add=TRUE)                                  # Add quadrat grid

# Compute the density for each quadrat
Q.d <- intensity(Q)
plot(intensity(Q, image=TRUE), main=NULL, las=1)  # Plot density raster
plot(starbucks, pch=20, cex=0.6, col=rgb(0,0,0,.5), add=TRUE)  # Add points

# Re-scale from m to km
starbucks.km <- rescale(starbucks, 1000, "km")
ma.km <- rescale(ma, 1000, "km")
pop.km    <- rescale(pop, 1000, "km")
pop.lg.km <- rescale(pop.lg, 1000, "km")

Q   <- quadratcount(starbucks.km, nx= 6, ny=3)
Q.d <- intensity(Q)
plot(intensity(Q, image=TRUE), main=NULL, las=1)  # Plot density raster
plot(starbucks.km, pch=20, cex=0.6, col=rgb(0,0,0,.5), add=TRUE)  # Add points

## Quadrat density on a tessellated surface ----
# Divide the population density covariate into four regions 
brk  <- c( -Inf, 4, 6, 8 , Inf)                 # Define the breaks
Zcut <- cut(pop.lg.km, breaks=brk, labels=1:4)  # Classify the raster
E    <- tess(image=Zcut)                        # Create a tesselated surface
plot(E, main="", las=1)

Q   <- quadratcount(starbucks.km, tess = E)   # Tally counts
Q.d <- intensity(Q)                           # Compute density
Q.d  # number of points per quadrat area

plot(intensity(Q, image=TRUE), las=1, main=NULL)
plot(starbucks.km, pch=20, cex=0.6, col=rgb(1,1,1,.5), add=TRUE)

# modify color pallette
cl <-  interp.colours(c("lightyellow", "orange" ,"red"), E$n) # 3 colors pallete
plot( intensity(Q, image=TRUE), las=1, col=cl, main=NULL)
plot(starbucks.km, pch=20, cex=0.6, col=rgb(0,0,0,.5), add=TRUE)

## Kernel density raster ----
# Computes an isotropic kernel intensity estimate of the point pattern.
K1 <- density(starbucks.km) # Using the default bandwidth
plot(K1, main=NULL, las=1)
contour(K1, add=TRUE)

K2 <- density(starbucks.km, sigma=50) # Using a 50km bandwidth
plot(K2, main=NULL, las=1)
contour(K2, add=TRUE)

K3 <- density(starbucks.km, kernel = "disc", sigma=50) # Change kernel to disc (default is gaussian)
plot(K3, main=NULL, las=1)
contour(K3, add=TRUE)


########### FOLLOWING THIS SECTION, I'M NOT UNDETSTAND ########################

## Kernel density adjusted for covariate ----
# Compute rho using the ratio method
rho <- rhohat(starbucks.km, pop.lg.km,  method="ratio")
# Generate rho vs covariate plot
plot(rho, las=1, main=NULL, legendargs=list(cex=0.8, xpd=TRUE, inset=c(1.01, 0) ))

pred <- predict(rho)
cl   <- interp.colours(c("lightyellow", "orange" ,"red"), 100)
plot(pred, col=cl, las=1, main=NULL, gamma = 0.25)

K1_vs_pred <- pairs(K1, pred, plot = FALSE)
plot(K1_vs_pred$pred ~ K1_vs_pred$K1, pch=20,
     xlab = "Observed intensity", 
     ylab = "Predicted intensity", 
     col = rgb(0,0,0,0.1))

K1_vs_K1 <- pairs(K1, K1, labels = c("K1a", "K1b"), plot = FALSE)
plot(K1_vs_K1$K1a ~ K1_vs_K1$K1b, pch=20,
     xlab = "Observed intensity", 
     ylab = "Observed intensity")

summary(as.data.frame(K1_vs_pred))
